#ifndef Pins_Arduino_h
#define Pins_Arduino_h

#include <avr/pgmspace.h>

// ATMEL ATMEGA1284P on Sleeping Beauty board designed by Wayne Chu
//	pins_arduino.h written by Roger Schaefer 2/28/2014 (untested)
//                     modified 3/22/2014  
//
//                       +---\/---+
//           (D 4) PB0 1 |        | 40 PA0 (D 21) AI 0
//           (D 5) PB1 2 |        | 39 PA1 (D 20) AI 1
//      INT2 (D 6) PB2 3 |        | 38 PA2 (D 19) AI 2
//       PWM (D 7) PB3 4 |        | 37 PA3 (D 18) AI 3
//   PWM/SS (D 10) PB4 5 |        | 36 PA4 (D 17) AI 4
//     MOSI (D 11) PB5 6 |        | 35 PA5 (D 16) AI 5
// PWM/MISO (D 12) PB6 7 |        | 34 PA6 (D 30) AI 6
//  PWM/SCK (D 13) PB7 8 |        | 33 PA7 (D 31) AI 7
//                 RST 9 |        | 32 AREF
//                VCC 10 |        | 31 GND 
//                GND 11 |        | 30 AVCC
//              XTAL2 12 |        | 29 PC7 (D 14) 
//              XTAL1 13 |        | 28 PC6 (D 15) 
//      RX0 (D 0) PD0 14 |        | 27 PC5 (D 27) TDI
//      TX0 (D 1) PD1 15 |        | 26 PC4 (D 26) TDO
// INT0 RX1 (D 2) PD2 16 |        | 25 PC3 (D 25) TMS
// INT1 TX1 (D 3) PD3 17 |        | 24 PC2 (D 24) TCK
//     PWM (D 22) PD4 18 |        | 23 PC1 (D 28) SDA
//      PWM (D 9) PD5 19 |        | 22 PC0 (D 29) SCL
//      PWM (D 8) PD6 20 |        | 21 PD7 (D 23) PWM
//                       +--------+
//
/*
+ *===========================================================================
+ *
+ * One of the major simplifications implemented by the Arduino core
+ * libraries is the ability to reference the IO pins by a BOARD-defined "Pin
+ * number" rather than needing to deal with the various IO register
+ * addresses and bit numbers or masks that microcontrollers normally use to
+ * access the external world.
+ *
+ * Of course, at some point the functions that use the "pin number" need to
+ * translate that abstraction into the actual IO address and bits need to
+ * manipulate them.  This is accomplished by core code in wiring_*.c that is
+ * essentially identical for each major chip architecture (ie "avr"), and
+ * this pins_arduino.h file that contains the specifics on a per-board or
+ * per-chip basis.
+ *
+ * Various algorithms are possible, and there can be significant differences
+ * depending on the capabilities of the architecture and chip being
+ * used. (for example, a PIC32 has separate Set and Clear IO registers for
+ * bitwise access, and an ARM CM3 might use "bit-banding")
+ *
+
+ * variants/<boarddesc>/pins_arduino.h contains the macros and/or tables
+ * used to convert from Arduino-style "pin numbers" (0-13 on Uno, for
+ * example) to the internal information necessary to perform operations on
+ * those pins.
+
+ *
+ *===========================================================================
*/


/*
+ * Most AVR-based Arduinos use tables built into flash (program) memory to
+ * do the bulk of work, so we'll need the avr-libc definitions for dealing
+ * with this additional address space.


+ * Total number of digital pins.  This includes any analog pins that could
+ * also be used for digital IO.
*/

#define NUM_DIGITAL_PINS            32

/*
+ * Total number of Analog Input pins
*/

#define NUM_ANALOG_INPUTS           8


/*
+ * Mapping macros
*/

#define analogInputToDigitalPin(p) \
  (\
    (p) == 0 ? 21 : \
    (p) == 1 ? 20 : \
    (p) == 2 ? 19 : \
    (p) == 3 ? 18 : \
    (p) == 4 ? 17 : \
    (p) == 5 ? 16 : \
    (p) == 6 ? 30 : \
    (p) == 7 ? 31 : \
    -1 )



extern const uint8_t digital_pin_to_pcint[NUM_DIGITAL_PINS];
extern const uint16_t __pcmsk[];
// comment next line to solve SPI problem?
//extern const uint8_t digital_pin_to_timer_PGM[NUM_DIGITAL_PINS];  

#define ifpin(p,what,ifnot)	    (((p) >= 0 && (p) < NUM_DIGITAL_PINS) ? (what) : (ifnot))
#define digitalPinHasPWM(p)         ifpin(p,pgm_read_byte(digital_pin_to_timer_PGM + (p)) != NOT_ON_TIMER,1==0)

#define digitalPinToAnalogPin(p) \
  (\
    (p) == 21 ? 0 : \
    (p) == 20 ? 1 : \
    (p) == 19 ? 2 : \
    (p) == 18 ? 3 : \
    (p) == 17 ? 4 : \
    (p) == 16 ? 5 : \
    (p) == 30 ? 6 : \
    (p) == 31 ? 7 : \
    -1 )

/*
 * This macro supports being passed an anlog pin # or the matching digital pin #
 * Note that this macro cheats by directly returning digitalPinToAnalog() since it is known
 * that there is a one to on mapping between the analog pin # and the analog channel
 */
#define analogPinToChannel(p) ( (p) < NUM_ANALOG_INPUTS ? (p) : digitalPinToAnalogPin(p) -1 ) 

/*===========================================================================*/

/*
+ * Names for Alternate pin functions.
+ * Note that the mapping from pin number to alternate function
+ * varies significantly from chip to chip.  An Uno and a MEGA are
+ * not the same, for example.
*/

/*
+ * SPI Peripheral pins
*/

static const uint8_t SS   = 10;
static const uint8_t MOSI = 11;
static const uint8_t MISO = 12;
static const uint8_t SCK  = 13;

/*
+ * I2C (TWI) peripheral pins
*/

static const uint8_t SDA = 28;
static const uint8_t SCL = 29;
static const uint8_t LED_BUILTIN = 13;
/*
+ * Alternate names for analog pins when accessed as digital IO
*/

static const uint8_t A0 = 21;
static const uint8_t A1 = 20;
static const uint8_t A2 = 19;
static const uint8_t A3 = 18;
static const uint8_t A4 = 17;
static const uint8_t A5 = 16;
static const uint8_t A6 = 30;
static const uint8_t A7 = 31;

#define digitalPinToPCICR(p)    ifpin(p,&PCICR,(uint8_t *)0)
#define digitalPinToPCICRbit(p) ifpin(p,digital_pin_to_pcint[p] >> 3,(uint8_t *)0)
#define digitalPinToPCMSK(p)    ifpin(p,__pcmsk[digital_pin_to_pcint[]],(uint8_t *)0)
#define digitalPinToPCMSKbit(p) ifpin(p,digital_pin_to_pcint[p] & 0x7,(uint8_t *)0)


//*===========================================================================*/
/*
+ * The data tables used to map the Arduino pins should only get defined ONCE
+ * in an entire sketch, usually in wiring_digital.c where they are most
+ * used.  Do this by making the definitions conditional on the ARDUINO_MAIN
+ * symbol, which is only defined (with #define) in that one source file.
+ *
+ * Other files can include pins_arduino.h to get the other defitions above.
*/

#ifdef ARDUINO_MAIN
// On the Arduino board, digital pins are also used
#define PA 1
#define PB 2
#define PC 3
#define PD 4

// PCINTxx to Dxx

const uint8_t digital_pin_to_pcint[NUM_DIGITAL_PINS] =
{
  24, // D0 PD0
  25, // D1 PD1
  26, // D2 PD2
  27, // D3 PD3
  8,  // D4 PB0
  9,  // D5 PB1
  10, // D6 PB2
  11, // D7 PB3
  30, // D8 PD6
  29, // D9 PD5
  12, // D10 PB4
  13, // D11 PB5
  14, // D12 PB6
  15, // D13 PB7
  23, // D14 PC7
  22, // D15 PC6
  5,  // D16 PA5
  4,  // D17 PA4
  3,  // D18 PA3
  2,  // D19 PA2
  1,  // D20 PA1
  0,  // D21 PA0
  28, // D22 PD4
  31, // D23 PD7
  18, // D24 PC2
  19, // D25 PC3
  20, // D26 PC4
  21, // D27 PC5
  17, // D28 PC1
  16, // D29 PC0
  6,  // D30 PA6
  7,  // D31 PA7
};

const uint16_t __pcmsk[] = 
{
  (uint16_t)&PCMSK0, 
  (uint16_t)&PCMSK1, 
  (uint16_t)&PCMSK2, 
  (uint16_t)&PCMSK3
};

/*===========================================================================*/
 
/*
+ * Pins are mapped in a two-step process.  First the pin number is
+ * translated into "port" (PA, PB, etc) which is just a small integer.
+ * Then the "port" is translated into an IO address depending on function.
+ * This allows different IO address for Read, Write, and Cofiguration.
+ * Separately the pin number is also translated to a bit mask within the
+ * IO address, which is assumed to be the same across all functions.
+ * Note that there is no requirement, and no guarantee, that adjacent
+ * pin numbers be on the same IO address, although this is somewhat true
+ * on Uno and other ATmegaxx8-based Arduinos.  Pins can be scattered across
+ * any number of ports in any order.
*/
 
// these arrays map port names (e.g. port B) to the
// appropriate addresses for various functions (e.g. reading
// and writing)

// port to configuration register address
const uint16_t PROGMEM port_to_mode_PGM[] =
{
	NOT_A_PORT,
	(uint16_t) &DDRA,
	(uint16_t) &DDRB,
	(uint16_t) &DDRC,
	(uint16_t) &DDRD,
};

// port to output register address

const uint16_t PROGMEM port_to_output_PGM[] =
{
	NOT_A_PORT,
	(uint16_t) &PORTA,
	(uint16_t) &PORTB,
	(uint16_t) &PORTC,
	(uint16_t) &PORTD,
};

// port to input register address

const uint16_t PROGMEM port_to_input_PGM[] =
{
	NOT_A_PORT,
	(uint16_t) &PINA,
	(uint16_t) &PINB,
	(uint16_t) &PINC,
	(uint16_t) &PIND,
};

/*
+ * Pin number to port mapping
*/

const uint8_t PROGMEM digital_pin_to_port_PGM[NUM_DIGITAL_PINS] =
{
  PD, // D0
  PD, // D1
  PD, // D2
  PD, // D3
  PB, // D4
  PB, // D5
  PB, // D6
  PB, // D7
  PD, // D8
  PD, // D9
  PB, // D10
  PB, // D11
  PB, // D12
  PB, // D13
  PC, // D14
  PC, // D15
  PA, // D16
  PA, // D17
  PA, // D18
  PA, // D19
  PA, // D20
  PA, // D21
  PD, // D22
  PD, // D23
  PC, // D24
  PC, // D25
  PC, // D26
  PC, // D27
  PC, // D28
  PC, // D29
  PA, // D30
  PA, // D31
};

/*
+ * Pin number to bitmask mapping.
+ * Note that _BV(n) is a mask with bit n set.  (1 << n)
*/

const uint8_t PROGMEM digital_pin_to_bit_mask_PGM[NUM_DIGITAL_PINS] =
{
  _BV(0), // D0 PD0
  _BV(1), // D1 PD1
  _BV(2), // D2 PD2
  _BV(3), // D3 PD3
  _BV(0), // D4 PB0
  _BV(1), // D5 PB1
  _BV(2), // D6 PB2
  _BV(3), // D7 PB3
  _BV(6), // D8 PD6
  _BV(5), // D9 PD5
  _BV(4), // D10 PB4
  _BV(5), // D11 PB5
  _BV(6), // D12 PB6
  _BV(7), // D13 PB7
  _BV(7), // D14 PC7
  _BV(6), // D15 PC6
  _BV(5), // D16 PA5
  _BV(4), // D17 PA4
  _BV(3), // D18 PA3
  _BV(2), // D19 PA2
  _BV(1), // D20 PA1
  _BV(0), // D21 PA0
  _BV(4), // D22 PD4
  _BV(7), // D23 PD7
  _BV(2), // D24 PC2
  _BV(3), // D25 PC3
  _BV(4), // D26 PC4
  _BV(5), // D27 PC5
  _BV(1), // D28 PC1
  _BV(0), // D29 PC0
  _BV(6), // D30 PA6
  _BV(7), // D31 PA7
};


/*
+ * Additionally, we have a table to tell us which timer is associated
+ * with a pin for use with the analogWrite() PWM function.  This allows
+ * the PWM to be turned off when digitalWrite() is used, and also is
+ * used by analogWrite() to compute which timer registers to modify.
+ * A pin that is not capable of doing PWM is mapped to NOT_ON_TIMER.
*/

const uint8_t PROGMEM digital_pin_to_timer_PGM[NUM_DIGITAL_PINS] =
{
  NOT_ON_TIMER, // D0 PD0
  NOT_ON_TIMER, // D1 PD1
  NOT_ON_TIMER, // D2 PD2
  NOT_ON_TIMER, // D3 PD3
  NOT_ON_TIMER, // D4 PB0
  NOT_ON_TIMER, // D5 PB1
  NOT_ON_TIMER, // D6 PB2
  TIMER0A,      // D7 PB3
  TIMER2B,      // D8 PD6
  TIMER1A,      // D9 PD5
  TIMER0B,      // D10 PB4
  NOT_ON_TIMER, // D11 PB5
  TIMER3A,      // D12 PB6
  TIMER3B,      // D13 PB7
  NOT_ON_TIMER, // D14 PC7
  NOT_ON_TIMER, // D15 PC6
  NOT_ON_TIMER, // D16 PA5
  NOT_ON_TIMER, // D17 PA4
  NOT_ON_TIMER, // D18 PA3
  NOT_ON_TIMER, // D19 PA2
  NOT_ON_TIMER, // D20 PA1
  NOT_ON_TIMER, // D21 PA0
  TIMER1B,      // D22 PD4
  TIMER2A,      // D23 PD7
  NOT_ON_TIMER, // D24 PC2
  NOT_ON_TIMER, // D25 PC3
  NOT_ON_TIMER, // D26 PC4
  NOT_ON_TIMER, // D27 PC5
  NOT_ON_TIMER, // D28 PC1
  NOT_ON_TIMER, // D29 PC0
  NOT_ON_TIMER, // D30 PA6
  NOT_ON_TIMER, // D31 PA7
};

#endif // ARDUINO_MAIN

#endif // Pins_Arduino_h
// vim:ai:cin:sts=2 sw=2 ft=cpp
